// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© LuxAlgo

//@version=5
indicator("Elliott Wave [LuxAlgo]", max_lines_count=500, max_labels_count=500, overlay=true, max_bars_back=5000)
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
i_hi  = input.string('high'        , title=        ''          , group='source [high - low]', inline='hl', options=['high', 'close', 'max open/close'])
i_lo  = input.string('low'         , title=        ''          , group='source [high - low]', inline='hl', options=['low' , 'close', 'min open/close'])

s1    = input.bool  (true          , title=        ''          , group='ZigZag'             , inline= '1'                                             )
len1  = input.int   ( 4            , title=        'Â Â 1 Length', group='ZigZag'             , inline= '1', minval =1                                  )
col1  = input.color (color.red   , title=        ''          , group='ZigZag'             , inline= '1'                                             )
s2    = input.bool  (true          , title=        ''          , group='ZigZag'             , inline= '2'                                             )
len2  = input.int   ( 8            , title=        'Â Â 2 Length', group='ZigZag'             , inline= '2', minval =1                                  )
col2  = input.color (color.blue  , title=        ''          , group='ZigZag'             , inline= '2'                                             )
s3    = input.bool  (true          , title=        ''          , group='ZigZag'             , inline= '3'                                             )                                           
len3  = input.int   (16            , title=        'Â Â 3 Length', group='ZigZag'             , inline= '3', minval =1                                  )
col3  = input.color (color.white , title=        ''          , group='ZigZag'             , inline= '3'                                             )


i_500 = input.float (0.500         , title='Â Â Â Â Â Â Â Â Â Â Â level 1', group='Fibonacci values'   ,              minval =0, maxval =1, step =0.01           )
i_618 = input.float (0.618         , title='Â Â Â Â Â Â Â Â Â Â Â level 2', group='Fibonacci values'   ,              minval =0, maxval =1, step =0.01           )
i_764 = input.float (0.764         , title='Â Â Â Â Â Â Â Â Â Â Â level 3', group='Fibonacci values'   ,              minval =0, maxval =1, step =0.01           )
i_854 = input.float (0.854         , title='Â Â Â Â Â Â Â Â Â Â Â level 4', group='Fibonacci values'   ,              minval =0, maxval =1, step =0.01           )

shZZ  = input.bool  (false         , title=         ''         , group='show ZZ'            , inline='zz'                                             )

//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
type ZZ 
    int  [] d
    int  [] x 
    float[] y 
    line [] l

type Ewave
    line   l1
    line   l2
    line   l3  
    line   l4
    line   l5
    label  b1
    label  b2
    label  b3
    label  b4
    label  b5
    //
    bool   on
    bool   br //= na
    //
    int    dir
    //
    line   lA
    line   lB
    line   lC
    label  bA
    label  bB
    label  bC
    //
    bool next = false
    //
    label  lb
    box    bx

type fibL
    line wave1_0_500 
    line wave1_0_618 
    line wave1_0_764 
    line wave1_0_854 
    line wave1_pole_ 
    linefill l_fill_ 
    bool     _break_ //= na

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
hi = i_hi == 'high' ? high : i_hi == 'close' ? close : math.max(open, close)
lo = i_lo == 'low'  ? low  : i_hi == 'close' ? close : math.min(open, close)

in_out(aZZ, d, x1, y1, x2, y2, col) =>
    aZZ.d.unshift(d), aZZ.x.unshift(x2), aZZ.y.unshift(y2), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop()
    if shZZ
        aZZ.l.unshift(line.new(x1, y1, x2, y2, color= col)), aZZ.l.pop().delete()

method isSame(Ewave gEW, _1x, _2x, _3x, _4x) => 
    t1 = _1x == gEW.l1.get_x1() 
    t2 = _2x == gEW.l2.get_x1() 
    t3 = _3x == gEW.l3.get_x1()  
    t4 = _4x == gEW.l4.get_x1()
    t1 and t2 and t3 and t4

method isSame2(Ewave gEW, _1x, _2x, _3x) => 
    t1 = _1x == gEW.l3.get_x2() 
    t2 = _2x == gEW.l4.get_x2()  
    t3 = _3x == gEW.l5.get_x2()
    t1 and t2 and t3 

method dot(Ewave gEW) =>
    gEW.l1.set_style(line.style_dotted)
    gEW.l2.set_style(line.style_dotted)
    gEW.l3.set_style(line.style_dotted)
    gEW.l4.set_style(line.style_dotted)
    gEW.l5.set_style(line.style_dotted)
    gEW.b1.set_textcolor    (color(na))
    gEW.b2.set_textcolor    (color(na))
    gEW.b3.set_textcolor    (color(na))
    gEW.b4.set_textcolor    (color(na))
    gEW.b5.set_textcolor    (color(na))
    gEW.on := false

method dash(Ewave gEW) =>
    gEW.lA.set_style(line.style_dashed)
    gEW.lB.set_style(line.style_dashed)
    gEW.lC.set_style(line.style_dashed)
    gEW.bA.set_textcolor    (color(na))
    gEW.bB.set_textcolor    (color(na))
    gEW.bC.set_textcolor    (color(na))
    gEW.bx.set_bgcolor      (color(na))
    gEW.bx.set_border_color (color(na))

method sol_dot(fibL nFibL, sol_dot, col) =>
    style = 
     sol_dot ==  'dot'  ? 
      line.style_dotted : 
     sol_dot ==  'sol'  ? 
      line.style_solid  :
      line.style_dashed
    nFibL.wave1_0_500.set_style(style)
    nFibL.wave1_0_618.set_style(style)
    nFibL.wave1_0_764.set_style(style)
    nFibL.wave1_0_854.set_style(style)
    nFibL.l_fill_.set_color(col)

method set(fibL nFibL, int x1, int x2, float max_500, float max_618, float max_764, float max_854, float y2) =>
    nFibL.wave1_0_500.set_xy1(x1, max_500)
    nFibL.wave1_0_500.set_xy2(x2, max_500)
    nFibL.wave1_0_618.set_xy1(x1, max_618)
    nFibL.wave1_0_618.set_xy2(x2, max_618)
    nFibL.wave1_0_764.set_xy1(x1, max_764)
    nFibL.wave1_0_764.set_xy2(x2, max_764)
    nFibL.wave1_0_854.set_xy1(x1, max_854)
    nFibL.wave1_0_854.set_xy2(x2, max_854)
    nFibL.wave1_pole_.set_xy1(x1,     y2 )
    nFibL.wave1_pole_.set_xy2(x1, max_854)
    nFibL.l_fill_.get_line1().set_xy1(x1, max_764)
    nFibL.l_fill_.get_line1().set_xy2(x2, max_764)
    nFibL.l_fill_.get_line2().set_xy1(x1, max_854)
    nFibL.l_fill_.get_line2().set_xy2(x2, max_854)

method setNa(fibL nFibL) =>
    nFibL.wave1_0_500.set_xy1(na, na)
    nFibL.wave1_0_500.set_xy2(na, na)
    nFibL.wave1_0_618.set_xy1(na, na)
    nFibL.wave1_0_618.set_xy2(na, na)
    nFibL.wave1_0_764.set_xy1(na, na)
    nFibL.wave1_0_764.set_xy2(na, na)
    nFibL.wave1_0_854.set_xy1(na, na)
    nFibL.wave1_0_854.set_xy2(na, na)
    nFibL.wave1_pole_.set_xy1(na, na)
    nFibL.wave1_pole_.set_xy2(na, na)
    nFibL.l_fill_.set_color(color(na))

draw(enabled, left, col, n) =>
    //
    max_bars_back(time, 2000)
    var int dir = na, var int x1= na, var float y1 = na, var int x2 = na, var float y2 = na, var Ewave gEW = na
    var int last_0x = na    ,  var float last_0y = na    ,   var int last_6x = na   ,    var float last_6y = na
    //
    if enabled
        var fibL nFibL = fibL.new(
           wave1_0_500 = line.new(na, na, na, na, color= color.new(col, 50), style= line.style_solid ),
           wave1_0_618 = line.new(na, na, na, na, color= color.new(col, 38), style= line.style_solid ),
           wave1_0_764 = line.new(na, na, na, na, color= color.new(col, 24), style= line.style_solid ),
           wave1_0_854 = line.new(na, na, na, na, color= color.new(col, 15), style= line.style_solid ),
           wave1_pole_ = line.new(na, na, na, na, color= color.new(col, 50), style= line.style_dashed),
               l_fill_ = linefill.new(
                         line.new(na, na, na, na, color= color(na))
                       , line.new(na, na, na, na, color= color(na))
                       ,                          color= color(na))
                       ,                         _break_   =   na
               )
        //
        var  ZZ        aZZ   =   ZZ.new(array.new < int   > ()
                                      , array.new < int   > ()
                                      , array.new < float > ()
                                      , array.new < line  > () )
        var Ewave[]    aEW   =          array.new < Ewave > ()
        //
        if barstate.isfirst
            aEW.unshift(Ewave.new())
            for i = 0 to 10
                aZZ.d.unshift(0)
                aZZ.x.unshift(0)
                aZZ.y.unshift(0)
                aZZ.l.unshift(shZZ ? line.new(na, na, na, na) : na)
        //
        sz       = aZZ.d.size( )
        x2      := bar_index -1
        ph       = ta.pivothigh(hi, left, 1)
        pl       = ta.pivotlow (lo, left, 1)
        t        = n == 2 ? '\n\n' : n == 1 ? '\n' : ''
        //
        // when a new Pivot High is found
        if not na(ph) 
            gEW := aEW.get   (0)
            dir := aZZ.d.get (0) 
            x1  := aZZ.x.get (0) 
            y1  := aZZ.y.get (0) 
            y2  :=      nz(hi[1])
            //
            if dir <  1  // if previous point was a pl, add, and change direction ( 1)
                in_out(aZZ,  1, x1, y1, x2, y2, col)
            else
                if dir ==  1 and ph > y1 
                    aZZ.x.set(0, x2), aZZ.y.set(0, y2)
                    if shZZ
                        aZZ.l.get(0).set_xy2(x2, y2)
            //
            _6x = x2, _6y = y2
            _5x = aZZ.x.get(1), _5y = aZZ.y.get(1)
            _4x = aZZ.x.get(2), _4y = aZZ.y.get(2)
            _3x = aZZ.x.get(3), _3y = aZZ.y.get(3)
            _2x = aZZ.x.get(4), _2y = aZZ.y.get(4)
            _1x = aZZ.x.get(5), _1y = aZZ.y.get(5)
            //
            // â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“[ 12345 ]â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
            _W5 = _6y - _5y
            _W3 = _4y - _3y
            _W1 = _2y - _1y
            min = math.min(_W1, _W3, _W5)
            isWave = 
             _W3 != min and
             _6y  > _4y and 
             _3y  > _1y and 
             _5y  > _2y
            // 
            same = gEW.isSame(_1x, _2x, _3x, _4x)
            if isWave
                if same
                    gEW.l5.set_xy2(_6x, _6y)
                    gEW.b5.set_xy (_6x, _6y)
                else
                    tx = ''
                    if _2x == aEW.get(0).b5.get_x() 
                        tx := '(5) (1)' 
                        aEW.get(0).b5.set_text('')
                    else
                        tx := '(1)'
                    //                
                    wave = Ewave.new(
                     l1  = line.new (_1x, _1y, _2x, _2y                      , color=col       , style= line.style_solid     ),
                     l2  = line.new (_2x, _2y, _3x, _3y                      , color=col       , style= line.style_solid     ),
                     l3  = line.new (_3x, _3y, _4x, _4y                      , color=col       , style= line.style_solid     ),
                     l4  = line.new (_4x, _4y, _5x, _5y                      , color=col       , style= line.style_solid     ),
                     l5  = line.new (_5x, _5y, _6x, _6y                      , color=col       , style= line.style_solid     ),
                     b1  = label.new(_2x, _2y, text= tx    + t, textcolor=col, color= color(na), style=label.style_label_down),
                     b2  = label.new(_3x, _3y, text= t + '(2)', textcolor=col, color= color(na), style=label.style_label_up  ),
                     b3  = label.new(_4x, _4y, text= '(3)' + t, textcolor=col, color= color(na), style=label.style_label_down),
                     b4  = label.new(_5x, _5y, text= t + '(4)', textcolor=col, color= color(na), style=label.style_label_up  ),
                     b5  = label.new(_6x, _6y, text= '(5)' + t, textcolor=col, color= color(na), style=label.style_label_down),
                     on  = true                                                                                               ,
                     br  = false                                                                                              ,
                     dir = 1
                      )
                    aEW.unshift(wave)
                    nFibL._break_ := false   
                    alert('New EW Motive Bullish Pattern found'  , alert.freq_once_per_bar_close)                                                                                       
            //
            if not isWave
                if same and gEW.on == true
                    gEW.dot() 
                    alert('Invalidated EW Motive Bullish Pattern', alert.freq_once_per_bar_close)                                                                                       
            //
            // â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“[ ABC ]â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
            getEW    = aEW.get(0)
            last_0x := getEW.l1.get_x1(), last_0y := getEW.l1.get_y1()
            last_6x := getEW.l5.get_x2(), last_6y := getEW.l5.get_y2()
            diff     = math.abs(last_6y - last_0y)
            //
            if getEW.dir == -1 
                getX    = getEW.l5.get_x2()                
                getY    = getEW.l5.get_y2() 
                isSame2 = getEW.isSame2  (_1x, _2x, _3x)
                isValid =
                   _3x == getX                  and 
                   _6y  < getY + (diff * i_854) and
                   _4y  < getY + (diff * i_854) and
                   _5y  > getY
                //
                if isValid
                    width = _6x - _2x // â€“â€“â€“[ width (4) - (c) ]â€“â€“â€“
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.lC.set_xy1(_5x, _5y), getEW.lC.set_xy2(_6x, _6y), getEW.bC.set_xy(_6x, _6y), getEW.bx.set_lefttop(_6x, _6y), getEW.bx.set_right(_6x + width)
                    else
                        getEW.lA := line.new (_3x, _3y, _4x, _4y, color=col), getEW.bA := label.new(_4x, _4y, text= '(a)' + t, textcolor=col, color= color(na), style=label.style_label_down)
                        getEW.lB := line.new (_4x, _4y, _5x, _5y, color=col), getEW.bB := label.new(_5x, _5y, text= t + '(b)', textcolor=col, color= color(na), style=label.style_label_up  )
                        getEW.lC := line.new (_5x, _5y, _6x, _6y, color=col), getEW.bC := label.new(_6x, _6y, text= '(c)' + t, textcolor=col, color= color(na), style=label.style_label_down)
                        getEW.bx := box.new  (_6x, _6y, _6x + width, _4y, bgcolor=color.new(col, 93), border_color=color.new(col, 65))
                        alert('New EW Corrective Bullish Pattern found'  , alert.freq_once_per_bar_close)                                                                                       
                else
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.dash()
                        alert('Invalidated EW Corrective Bullish Pattern', alert.freq_once_per_bar_close)                                                                                       
            //
            // â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“[ new (1) ? ]â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
            if getEW.dir ==  1 
                if _5x == getEW.bC.get_x() and 
                   _6y >  getEW.b5.get_y() and
                   getEW.next  == false
                    getEW.next := true
                    getEW.lb   := label.new(_6x, _6y, style=label.style_circle, color=color.new(col, 65), yloc=yloc.abovebar, size=size.tiny)
                    alert('Possible new start of EW Motive Bullish Wave', alert.freq_once_per_bar_close)                                                                                       
        //
        // when a new Pivot Low is found
        if not na(pl) 
            gEW := aEW.get   (0)
            dir := aZZ.d.get (0) 
            x1  := aZZ.x.get (0) 
            y1  := aZZ.y.get (0) 
            y2  :=      nz(lo[1])
            //
            if dir > -1  // if previous point was a ph, add, and change direction (-1)
                in_out(aZZ, -1, x1, y1, x2, y2, col)
            else
                if dir == -1 and pl < y1 
                    aZZ.x.set(0, x2), aZZ.y.set(0, y2)
                    if shZZ
                        aZZ.l.get(0).set_xy2(x2, y2)
            //
            _6x = x2, _6y = y2
            _5x = aZZ.x.get(1), _5y = aZZ.y.get(1)
            _4x = aZZ.x.get(2), _4y = aZZ.y.get(2)
            _3x = aZZ.x.get(3), _3y = aZZ.y.get(3)
            _2x = aZZ.x.get(4), _2y = aZZ.y.get(4)
            _1x = aZZ.x.get(5), _1y = aZZ.y.get(5)
            //
            // â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“[ 12345 ]â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
            _W5 = _5y - _6y
            _W3 = _3y - _4y
            _W1 = _1y - _2y
            min = math.min(_W1, _W3, _W5)
            isWave = 
             _W3 != min and
             _4y  > _6y and 
             _1y  > _3y and 
             _2y  > _5y
            // 
            same = isSame(gEW, _1x, _2x, _3x, _4x)
            if isWave
                if same
                    gEW.l5.set_xy2(_6x, _6y)
                    gEW.b5.set_xy (_6x, _6y)
                else
                    tx = ''
                    if _2x == aEW.get(0).b5.get_x() 
                        tx := '(5) (1)' 
                        aEW.get(0).b5.set_text('')
                    else
                        tx := '(1)'
                    //
                    wave = Ewave.new(
                     l1  = line.new (_1x, _1y, _2x, _2y                      , color=col       , style= line.style_solid     ),
                     l2  = line.new (_2x, _2y, _3x, _3y                      , color=col       , style= line.style_solid     ),
                     l3  = line.new (_3x, _3y, _4x, _4y                      , color=col       , style= line.style_solid     ),
                     l4  = line.new (_4x, _4y, _5x, _5y                      , color=col       , style= line.style_solid     ),
                     l5  = line.new (_5x, _5y, _6x, _6y                      , color=col       , style= line.style_solid     ),
                     b1  = label.new(_2x, _2y, text= t    + tx, textcolor=col, color= color(na), style=label.style_label_up  ),
                     b2  = label.new(_3x, _3y, text= '(2)' + t, textcolor=col, color= color(na), style=label.style_label_down),
                     b3  = label.new(_4x, _4y, text= t + '(3)', textcolor=col, color= color(na), style=label.style_label_up  ),
                     b4  = label.new(_5x, _5y, text= '(4)' + t, textcolor=col, color= color(na), style=label.style_label_down),
                     b5  = label.new(_6x, _6y, text= t + '(5)', textcolor=col, color= color(na), style=label.style_label_up  ),
                     on  = true                                                                                               ,
                     br  = false                                                                                              ,
                     dir =-1
                      )
                    aEW.unshift(wave)
                    nFibL._break_ := false 
                    alert('New EW Motive Bearish Pattern found'  , alert.freq_once_per_bar_close)                                                                                                                                                            
            //        
            if not isWave
                if same and gEW.on == true
                    gEW.dot()   
                    alert('Invalidated EW Motive Bearish Pattern', alert.freq_once_per_bar_close)                                                                                       
            //
            // â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“[ ABC ]â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
            getEW    = aEW.get(0)
            last_0x := getEW.l1.get_x1(), last_0y := getEW.l1.get_y1()
            last_6x := getEW.l5.get_x2(), last_6y := getEW.l5.get_y2()
            diff     = math.abs(last_6y - last_0y)
            //
            if getEW.dir ==  1 
                getX    = getEW.l5.get_x2()                
                getY    = getEW.l5.get_y2() 
                isSame2 = getEW.isSame2  (_1x, _2x, _3x)
                isValid =
                   _3x == getX                  and 
                   _6y  > getY - (diff * i_854) and
                   _4y  > getY - (diff * i_854) and
                   _5y  < getY
                //
                if isValid
                    width = _6x - _2x // â€“â€“â€“[ width (4) - (c) ]â€“â€“â€“
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.lC.set_xy1(_5x, _5y), getEW.lC.set_xy2(_6x, _6y), getEW.bC.set_xy(_6x, _6y), getEW.bx.set_lefttop(_6x, _6y), getEW.bx.set_right(_6x + width)
                    else
                        getEW.lA := line.new (_3x, _3y, _4x, _4y, color=col), getEW.bA := label.new(_4x, _4y, text= t + '(a)', textcolor=col, color= color(na), style=label.style_label_up  )
                        getEW.lB := line.new (_4x, _4y, _5x, _5y, color=col), getEW.bB := label.new(_5x, _5y, text= '(b)' + t, textcolor=col, color= color(na), style=label.style_label_down)
                        getEW.lC := line.new (_5x, _5y, _6x, _6y, color=col), getEW.bC := label.new(_6x, _6y, text= t + '(c)', textcolor=col, color= color(na), style=label.style_label_up  )
                        getEW.bx := box.new  (_6x, _6y, _6x + width, _4y, bgcolor=color.new(col, 93), border_color=color.new(col, 65))
                        alert('New EW Corrective Bearish Pattern found'  , alert.freq_once_per_bar_close)                                                                                       
                else
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.dash() 
                        alert('Invalidated EW Corrective Bullish Pattern', alert.freq_once_per_bar_close)                                                                                       
            //
            // â€“â€“â€“[ check (only once) for a possible new (1) after an impulsive AND corrective wave ]â€“â€“â€“
            if getEW.dir == -1 
                if _5x == getEW.bC.get_x() and 
                   _6y <  getEW.b5.get_y() and
                   getEW.next  == false
                    getEW.next := true
                    getEW.lb   := label.new(_6x, _6y, style=label.style_circle, color=color.new(col, 65), yloc=yloc.belowbar, size=size.tiny)
                    alert('Possible new start of EW Motive Bearish Wave', alert.freq_once_per_bar_close)                                                                                       
        //                    
        // â€“â€“â€“[ check for break box ]â€“â€“â€“
        if aEW.size() > 0
            gEW    := aEW.get(0)
            if gEW.dir == 1 
                if ta.crossunder(low , gEW.bx.get_bottom()) and bar_index <= gEW.bx.get_right()
                    label.new(bar_index, low , yloc= yloc.belowbar, style= label.style_xcross, color=color.red, size=size.tiny)
            else
                if ta.crossover (high, gEW.bx.get_top   ()) and bar_index <= gEW.bx.get_right()
                    label.new(bar_index, high, yloc= yloc.abovebar, style= label.style_xcross, color=color.red, size=size.tiny)       
        //
        if barstate.islast
            //  â€“â€“â€“[ get last 2 EW's ]â€“â€“â€“
            getEW    = aEW.get(0)
            if aEW.size() > 1
                getEW1   = aEW.get(1)
                last_0x := getEW.l1.get_x1(), last_0y := getEW.l1.get_y1()
                last_6x := getEW.l5.get_x2(), last_6y := getEW.l5.get_y2()
                //
                diff = math.abs(last_6y - last_0y) // â€“â€“â€“[ max/min difference ]â€“â€“â€“
                _500 = diff * i_500
                _618 = diff * i_618
                _764 = diff * i_764
                _854 = diff * i_854
                bull = getEW.dir == 1 
                // â€“â€“â€“[ if EW is not valid or an ABC has developed -> remove fibonacci lines ]â€“â€“â€“
                if getEW.on == false or getEW.bC.get_x() > getEW.b5.get_x()
                    nFibL.setNa()
                else
                // â€“â€“â€“[ get.on == true ~ valid EW ]â€“â€“â€“
                    max_500 = last_6y + ((bull ? -1 : 1) * _500)
                    max_618 = last_6y + ((bull ? -1 : 1) * _618)
                    max_764 = last_6y + ((bull ? -1 : 1) * _764)
                    max_854 = last_6y + ((bull ? -1 : 1) * _854)
                    //
                    nFibL.set(last_6x, bar_index + 10, max_500, max_618, max_764, max_854, last_6y)
                // â€“â€“â€“[ if (2) label overlap with (C) label ]â€“â€“â€“
                if  getEW.b2.get_x() == getEW1.bC.get_x()
                    getEW.b1.set_textcolor(color(na))
                    getEW.b2.set_textcolor(color(na))
                    strB  = getEW1.bB.get_text() 
                    strC  = getEW1.bC.get_text()
                    strB_ = str.replace(strB, "(b)",  "(b) (1)", 0)
                    strC_ = str.replace(strC, "(c)",  "(c) (2)", 0)
                    getEW1.bB.set_text(strB_)
                    getEW1.bC.set_text(strC_)
            //        
            // â€“â€“â€“[ check if fib limits are broken ]â€“â€“â€“
            getP_854 = nFibL.wave1_0_854.get_y1()
            for i = 0 to bar_index - nFibL.wave1_0_854.get_x1()
                if getEW.dir == -1
                    if high[i] > getP_854
                        nFibL._break_ := true
                        break
                else
                    if low [i] < getP_854
                        nFibL._break_ := true
                        break  
            //â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
            switch nFibL._break_
                true  => nFibL.sol_dot('dot', color.new(color.red , 95))
                false => nFibL.sol_dot('sol', color.new(color.lime, 95))
                => 
                    nFibL.wave1_0_500.set_xy1(na, na)
                    nFibL.wave1_0_500.set_xy2(na, na)
                    nFibL.wave1_0_618.set_xy1(na, na)
                    nFibL.wave1_0_618.set_xy2(na, na)
                    nFibL.wave1_0_764.set_xy1(na, na)
                    nFibL.wave1_0_764.set_xy2(na, na)
                    nFibL.wave1_0_854.set_xy1(na, na)
                    nFibL.wave1_0_854.set_xy2(na, na)
                    nFibL.wave1_pole_.set_xy1(na, na)
                    nFibL.wave1_pole_.set_xy2(na, na)
                    nFibL.l_fill_.set_color(color(na))

        if aEW.size() > 15 
            pop = aEW.pop()
            pop.l1.delete(), pop.b1.delete()
            pop.l2.delete(), pop.b2.delete()
            pop.l3.delete(), pop.b3.delete()
            pop.l4.delete(), pop.b4.delete()
            pop.l5.delete(), pop.b5.delete()
            pop.lA.delete(), pop.bA.delete()
            pop.lB.delete(), pop.bB.delete()
            pop.lC.delete(), pop.bC.delete()
            pop.lb.delete(), pop.bx.delete()
        //----------------------------------

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
draw(s1, len1, col1, 0)
draw(s2, len2, col2, 1)
draw(s3, len3, col3, 2)

//-----------------------------------------------------------------------------}

//********************************************************************






// User Inputs
lookBack = input.int(200, title = "Volume Lookback Depth", minval = 10, maxval = 1000, tooltip = "The number of bars to look back for calculating the volume profile.")
maxBars = input.int(250, title = "Number of Bars", minval = 10, maxval = 300, tooltip = "The number of horizontal bars to use for the volume profile.")
barMultiplier = input.int(40, title = "Bar Length Multiplier", minval = 10, maxval = 500, tooltip = "Multiplier to adjust the length of the volume profile bars.")
horizontalOffset = input.int(defval = 45, title = "Bar Horizontal Offset", minval = -100, maxval = 100, tooltip = "Horizontal offset for the volume profile from the most recent bar.")
barWidth = input.int(4, title = "Bar Width", minval = 1, maxval = 20, tooltip = "The width of the volume profile bars.")
showPOC = input.bool(defval = true, title = "Show POC", tooltip = "Enable to show the Point of Control (POC) on the volume profile.")
showCumulative = input.bool(defval = true, title = "Show Cumulative Volume", tooltip = "Enable to show the cumulative volume for each price level.")
showPressure = input.bool(defval = true, title = "Show Buy/Sell Pressure", tooltip = "Enable to show buy/sell pressure at each price level.")
barColor = input(color.new(#666666, 15), title = "Cumulative Volume Color")
pocColor = input(color.rgb(242, 54, 69, 15), title = "POC Color")
bullColor = input(color.rgb(8, 153, 129, 15), title = "Buy Pressure Color")
bearColor = input(color.rgb(242, 54, 69, 15), title = "Sell Pressure Color")

// Initialize Variables
var hideProfile = na(volume)
var float maxVolume = 0.0
var float maxVolumeBullBear = 0.0
var int maxVolumeIndex = 0
barTimeChange = ta.change(time)

priceLevels = array.new_float((maxBars + 1), 0.0)
cumulativeVolume = array.new_float(maxBars, 0.0)
deltaVolume = array.new_float(maxBars, 0.0)
bullBearVolume = array.new_float(maxBars, 0.0)
cumulativeBullBearVolume = array.new_float(maxBars, 0.0)
barHeightsCumulative = array.new_int(maxBars, 0)
barHeightsBullBear = array.new_int(maxBars, 0)

float highestHigh = ta.highest(high, lookBack)
float lowestLow = ta.lowest(low, lookBack)

// Calculate Price Levels
if barstate.islast and not hideProfile
    float priceRange = (highestHigh - lowestLow) / maxBars
    for j = 1 to (maxBars + 1)
        array.set(priceLevels, (j-1), (lowestLow + priceRange * j))
    
    // Calculate Delta Volume and Cumulative Volume
    for i = 0 to (lookBack - 1)
        int deltaCounter = 0
        int bullBearCounter = 0
        array.fill(deltaVolume, 0.0)
        array.fill(bullBearVolume, 0.0)
        for j = 0 to (maxBars - 1)
            float priceLevel = array.get(priceLevels, j)
            if low[i] < priceLevel and high[i] > priceLevel
                float bullVolume = 0.0
                float bearVolume = 0.0
                float dominantVolume = 0.0
                float currentVolume = array.get(bullBearVolume, j)
                if close[i] >= open[i]
                    bullVolume := nz(volume[i])
                if close[i] <= open[i]
                    bearVolume := nz(volume[i])
                if bullVolume > bearVolume
                    dominantVolume := currentVolume + bullVolume
                    array.set(bullBearVolume, j, dominantVolume)
                else if bullVolume < bearVolume
                    dominantVolume := currentVolume - bearVolume
                    array.set(bullBearVolume, j, dominantVolume)
                bullBearCounter := bullBearCounter + 1
                array.set(deltaVolume, j, array.get(deltaVolume, j) + nz(volume[i]))
                deltaCounter := deltaCounter + 1
        for j = 0 to (maxBars - 1)
            float currentCumulativeVolume = array.get(cumulativeVolume, j)
            float currentDeltaVolume = array.get(deltaVolume, j)
            float updatedCumulativeVolume = currentCumulativeVolume + ((deltaCounter > 0) ? (currentDeltaVolume / deltaCounter) : 0.0)
            array.set(cumulativeVolume, j, updatedCumulativeVolume)
            float currentCumulativeBullBearVolume = array.get(cumulativeBullBearVolume, j)    
            float currentBullBearVolume = array.get(bullBearVolume, j)
            float updatedCumulativeBullBearVolume = currentCumulativeBullBearVolume + ((bullBearCounter > 0) ? (currentBullBearVolume / bullBearCounter) : 0.0)
            array.set(cumulativeBullBearVolume, j, updatedCumulativeBullBearVolume)
    
    // Find Maximum Cumulative Volume
    maxVolume := array.max(cumulativeVolume)
    maxVolumeIndex := array.indexof(cumulativeVolume, maxVolume)
    
    // Calculate Bar Heights
    for j = 0 to (maxBars - 1)
        float currentVolume = array.get(cumulativeVolume, j)
        int barHeight = math.round(barMultiplier * (currentVolume / maxVolume))
        array.set(barHeightsCumulative, j, barHeight)
        float currentVolumeBullBear = array.get(cumulativeBullBearVolume, j)
        int barHeightBullBear = math.round(barMultiplier * (currentVolumeBullBear / maxVolume))
        array.set(barHeightsBullBear, j, barHeightBullBear)

endX = bar_index + horizontalOffset

// Set Up Bars
setupBarCumulative(n) =>
    startX = ((maxVolumeIndex == n) and showPOC) ? bar_index - lookBack : endX - array.get(barHeightsCumulative, n)
    price = array.get(priceLevels, n)
    line.new(x1     = startX,
             y1     = price,
             x2     = endX,
             y2     = price,
             xloc   = xloc.bar_index,
             extend = extend.none,
             color  = (maxVolumeIndex == n and showPOC ? pocColor : barColor),
             style  = line.style_solid,
             width  = (maxVolumeIndex == n and showPOC ? barWidth + 1 : barWidth))

setupBarBullBear(n) =>
    barHeight = array.get(barHeightsBullBear, n)
    isBearVolume = 1
    if barHeight > 0
        isBearVolume := 0
        barHeight := barHeight * -1
    startX = endX - barHeight
    price = array.get(priceLevels, n)
    line.new(x1     = startX,
             y1     = price,
             x2     = endX,
             y2     = price,
             xloc   = xloc.bar_index,
             extend = extend.none,
             color  = (isBearVolume ? bearColor : bullColor),
             style  = line.style_solid,
             width  = barWidth)

// Draw Bars
if barstate.islast and not hideProfile
    for i = 0 to (maxBars - 1) by 1
        if showCumulative
            setupBarCumulative(i)
        if showPressure
            setupBarBullBear(i)


        

//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{

swpGR = 'Session Sweeps'
swpBZ = input.bool (true, 'Buyside Sweep Zones', inline = 'SWPB', group = swpGR)
swpBC = input.color(color.new(color.orange, 37), '', inline = 'SWPB', group = swpGR)
swpBM = input.float(1.3, 'Margin', minval = .5, maxval = 10, step = .1, inline = 'SWPB', group = swpGR)

swpSZ = input.bool (true, 'Sellside Sweep Zones', inline = 'SWPS', group = swpGR)
swpSC = input.color(color.new(color.blue, 37), '', inline = 'SWPS', group = swpGR)
swpSM = input.float(1.3, 'Margin', minval = .5, maxval = 10, step = .1, inline = 'SWPS', group = swpGR)

swpML = input.int(5, 'â€ƒâ€ƒSweep Margin Length', minval = 2, maxval = 10, group = swpGR)
swpDT = input.bool(false, 'Detect Sweeps Once per Session', group = swpGR)

swpHF = input.bool(false, 'Hide Fake Sweep Zones', inline = 'SWPF', group = swpGR)
swpFC = input.color(color.new(#787b86, 73), '', inline = 'SWPF', group = swpGR)

sesGR   = "Sessions"
h01 = '01:00', h02 = '02:00', h03 = '03:00', h04 = '04:00', h05 = '05:00', h06 = '06:00'
h07 = '07:00', h08 = '08:00', h09 = '09:00', h10 = '10:00', h11 = '11:00', h12 = '12:00'
h13 = '13:00', h14 = '14:00', h15 = '15:00', h16 = '16:00', h17 = '17:00', h18 = '18:00'
h19 = '19:00', h20 = '20:00', h21 = '21:00', h22 = '22:00', h23 = '23:00', h00 = '00:00'

asSH    = input.bool(true , '', inline='AS' , group = sesGR)
asST    = input.string('Asia' , '', inline='AS' , group = sesGR)
asSRT   = input.string(h09, '' , options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='AS', group = sesGR)
asEND   = input.string(h18, '-', options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='AS', group = sesGR)
asC     = input.color(color.new(color.yellow, 0), 'â€ƒâ€ƒ', inline='AS1', group = sesGR)
asMMP   = input.bool (true, 'Extend : Max/Min | Mid', inline = 'AS1', group = sesGR)
asSM    = input.bool(false , '', inline = 'AS1', group = sesGR)
asBG    = input.bool (true, 'Fill', inline = 'AS1', group = sesGR)

ldnSH   = input.bool(true , ''  , inline='LDN' , group = sesGR)
ldnST   = input.string('London' , '', inline='LDN' , group = sesGR)
ldnSRT  = input.string(h08, '' , options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='LDN', group = sesGR)
ldnEND  = input.string(h17, '-', options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='LDN', group = sesGR)
ldnC    = input.color(color.new(color.blue, 0), 'â€ƒâ€ƒ', inline='LDN1', group = sesGR)
ldnMMP  = input.bool (true, 'Extend : Max/Min | Mid', inline = 'LDN1', group = sesGR)
ldnSM   = input.bool(false , '', inline = 'LDN1', group = sesGR)
ldnBG   = input.bool (true, 'Fill', inline = 'LDN1', group = sesGR)

nyamSH  = input.bool(true , ''  , inline='NYA' , group = sesGR)
nyamST  = input.string('NY AM' , '', inline='NYA' , group = sesGR)
nyamSRT = input.string(h08, '' , options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='NYA', group = sesGR)
nyamEND = input.string(h13, '-', options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='NYA', group = sesGR)
nyamC   = input.color(color.new(color.orange, 0), 'â€ƒâ€ƒ', inline='NYA1', group = sesGR)
nyamMMP = input.bool (true, 'Extend : Max/Min | Mid', inline = 'NYA1', group = sesGR)
nyamSM  = input.bool(false , '', inline = 'NYA1', group = sesGR)
nyamBG  = input.bool (true, 'Fill', inline = 'NYA1', group = sesGR)

nypmSH  = input.bool(true , ''  , inline='NYP' , group = sesGR)
nypmST  = input.string('NY PM' , '', inline='NYP' , group = sesGR)
nypmSRT = input.string(h13, '' , options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='NYP', group = sesGR)
nypmEND = input.string(h19, '-', options = [h00, h01, h02, h03, h04, h05, h06, h07, h08, h09, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23], inline='NYP', group = sesGR)
nypmC   = input.color(color.new(color.red, 0), 'â€ƒâ€ƒ', inline='NYP1', group = sesGR)
nypmMMP = input.bool (true, 'Extend : Max/Min | Mid', inline = 'NYP1', group = sesGR)
nypmSM  = input.bool(false, '', inline = 'NYP1', group = sesGR)
nypmBG  = input.bool (true, 'Fill', inline = 'NYP1', group = sesGR)

nyDST   = input.bool(false , 'New York DST | London DST', inline = 'DST', group = sesGR, tooltip = 'New York - Daylight Saving Time (DST)\n *DST Start : Second Sunday in March at 2:00\n *DST End : First Sunday in November at 2:00\n\nLondon - Daylight saving time (DST)\n *DST Start : Last Sunday in March at 1:00\n *DST End : Last Sunday in October at 1:00')
ldnDST  = input.bool(false , '', inline = 'DST', group = sesGR)

sesDET  = input.bool(true , 'Sessions Extreme Lines | Sessions Names', inline = 'NAM', group = sesGR)
sesNM   = input.bool(true , '', inline = 'NAM', group = sesGR)
sesLNW  = input.int(1 , 'â€ƒâ€ƒSession Lines Width', group = sesGR)
sesFT   = input.int(95, 'â€ƒâ€ƒSession Fill Transparency', minval = 0, maxval = 100, group = sesGR)

mssGR   = 'Market Structure Shifts'
mssSH   = input.bool(false, 'Market Structure Shifts', group = mssGR)
mssLN   = input.int(8, "Detection Length", minval = 1, group = mssGR)
ppLCB   = input.color(color.new(color.teal, 0), 'Market Structure Shifts : Bullish', inline = 'MSS', group = mssGR)
ppLCS   = input.color(color.new(color.red, 0), 'Bearish', inline = 'MSS', group = mssGR)

fvgGR   = 'Fair Value Gaps'
fvgSH   = input.bool(false, 'Fair Value Gaps', group = fvgGR)
fvgTT   = 'The script displays the fair value gaps whose width is larger than a fixed-length atr (average true range) value multiplied by the value of the option.\n\n' + 
         'The option value set to 0 means no filtering is applied.\n\n' + 
         'Remark: no filtering will be applied for the first 144 (atr fixed-length) candles since the atr value won\'t be present'
fvgTH   = input.float(1, 'Fair Value Gap Width Filter', minval = 0, step = .1, tooltip = fvgTT, group = fvgGR)

fvgBC   = input.color(color.new(color.teal, 80), 'Bullish Imbalance', inline = 'FVG', group = fvgGR)
fvgSC   = input.color(color.new(color.red, 80), 'Bearish Imbalance', inline = 'FVG', group = fvgGR)

sesOTH  = 'Sessions Tabular View'
sesTSH  = input.bool(true , 'Sessions Tabular View'  , group = sesOTH, tooltip = 'Displays sessions tabular view\n - Date and Time,\n - Sessions Opening/Closing Countdown Timer and\n - Session Status')
hIfN    = input.bool(false, 'Hide if not Forex Market Instrument'  , group = sesOTH)
sesTS   = input.string("Small", "â€ƒâ€ƒTable Text Size", options = [ "Tiny", "Small", "Normal"], inline='STAT',group = sesOTH)
sesTS  := sesTS == "Small" ? size.small : sesTS == "Normal" ? size.normal : size.tiny
sesPOS  = input.string('Top Right', '', options = ['Top Left', 'Top Center', 'Top Right', 'Middle Right', 'Bottom Left', 'Bottom Center'], inline='STAT', group = sesOTH) 

//-----------------------------------------------------------------------------}
// User Defined Types
//-----------------------------------------------------------------------------{

type bar
    float o = open
    float h = high
    float l = low
    float c = close
    int   i = bar_index

type session 
    string  []  s
    float   []  oH
    float   []  cH
    int     []  tO

    line        lnSHp
    line        lnSMp
    line        lnSLp
    float       fSHp
    float       fSLp

    box         bzBX
    box         szBX
    bool        bzB
    bool        bsB
    bool        szB
    bool        ssB

    box         lbzBX
    box         lszBX
    bool        lbzB
    bool        lbsB
    bool        lszB
    bool        lssB

type pivotPoint
    float  h
    int    ht
    bool   hx 

    float  l
    int    lt
    bool   lx

type FVG
    box  [] uFVG

//-----------------------------------------------------------------------------}
// Variables
//-----------------------------------------------------------------------------{

bar b = bar.new()

tfM = timeframe.multiplier

var session S = session.new(
     array.new <string>  (na),
     array.new <float>   (na),
     array.new <float>   (na),
     array.new <int>     (na),
     line(na), line(na), line(na), na, na, box(na), box(na), 
     false, false, false, false,
     box(na), box(na), 
     false, false, false, false
 )

swpATR = ta.atr(21)

var pivotPoint pp = pivotPoint.new()
var shift = 0

var FVG fvg = FVG.new(array.new <box>  (na))
fvgATR = nz(ta.atr(144)) * fvgTH
var bool last = na 

if barstate.isfirst 
    S.s.push('Asia')  , S.oH.push(09), S.cH.push(14), S.tO.push(09)
    S.s.push('London'), S.oH.push(05), S.cH.push(13), S.tO.push(00)
    S.s.push('NY AM') , S.oH.push(08), S.cH.push(13), S.tO.push(-5)
    S.s.push('NY PM') , S.oH.push(13), S.cH.push(19), S.tO.push(-5)

//-----------------------------------------------------------------------------}
// Functions / Methods
//-----------------------------------------------------------------------------{

f_whatIsTheTime(_ses, _dst) =>
    TZ = 'Etc/UTC'
    DST = _dst ? 1 : 0
    utcTime = (S.tO.get(S.s.indexof(_ses)) + DST) * 3600000 + timenow
    [math.floor(utcTime / 3600000) % 24, math.floor(utcTime / 60000) % 60, math.floor(utcTime / 1000) % 60, dayofmonth(int(utcTime), TZ), month(int(utcTime), TZ), year(int(utcTime), TZ), dayofweek(int(utcTime), TZ)]

f_sesDet(_ses, _dst) =>
    [h, m, s, D, M, Y, A] = f_whatIsTheTime(_ses, _dst)

    ht = h < 10 ? '0' + str.tostring(h) : str.tostring(h)
    mt = m < 10 ? '0' + str.tostring(m) : str.tostring(m)
    st = s < 10 ? '0' + str.tostring(s) : str.tostring(s)
    Dt = D < 10 ? '0' + str.tostring(D) : str.tostring(D)
    Mt = M < 10 ? '0' + str.tostring(M) : str.tostring(M)
    Yt = str.tostring(Y)
    dateTime = Dt + '/' + Mt + '/' + Yt + '-' + ht + ':' + mt + ':' + st

    if A != 1 and A != 7
        SoH = S.oH.get(S.s.indexof(_ses))
        ScH = S.cH.get(S.s.indexof(_ses))
        market = if h >= SoH and h < ScH
            hc = ScH - h - 1
            mc = 60 - m - 1
            sc = 60 - s
            sct = sc < 10 ? '0' + str.tostring(sc) : str.tostring(sc)
            mct = mc < 10 ? '0' + str.tostring(mc) : str.tostring(mc)
            hct = hc < 10 ? '0' + str.tostring(hc) : str.tostring(hc)
            closes = hct + ':' + mct + ':' + sct
            if hc == 0
                sc % 2 == 0 ? dateTime + ' ðŸŸ¢ Closes in ' + closes : dateTime + ' ðŸ”´ Closes in ' + closes
            else
                dateTime + ' ðŸŸ¢ Closes in ' + closes
        else
            ho = if h < SoH
                SoH - h - 1
            else
                24 - h + SoH - 1
            mo = 60 - m - 1
            so = 60 - s
            sot = so < 10 ? '0' + str.tostring(so) : str.tostring(so)
            mot = mo < 10 ? '0' + str.tostring(mo) : str.tostring(mo)
            hot = ho < 10 ? '0' + str.tostring(ho) : str.tostring(ho)
            opens = hot + ':' + mot + ':' + sot
            if h >= ScH and A == 6
                dateTime + ' ðŸŸ  Weekend'
            else
                if ho == 0
                    so % 2 == 0 ? dateTime + ' ðŸ”´ Opens in ' + opens : dateTime + ' ðŸŸ¢ Opens in ' + opens
                else
                    dateTime + ' ðŸ”´ Opens in ' + opens
        market
    else
        dateTime + ' ðŸŸ  Weekend'

f_gSesI( _ses, _dst) =>
    TZ  = 'Etc/UTC'
    DST = _dst ? 1 : 0
    SES = S.s.indexof(_ses)
    utcTime = (S.tO.get(SES) + DST) * 3600000 + time
    h = math.floor(utcTime / 3600000) % 24

    h >= S.oH.get(SES) and h < S.cH.get(SES)

f_pSWP(_show, _cSes, _sSes, _dst, _cC, _mm, _bg, _sM) =>
    var line lnSHc = na, var line lnSLc = na, var box bxSTc = na
    var line llnSHc = na, var line llnSLc = na, var line llnSMc = na

    if _show 
        cSES = f_gSesI(_cSes, _dst)

        if cSES and cSES != cSES[1]
            lnSHc := line.new(b.i, b.h, b.i, b.h, xloc.bar_index, extend.none, color.new(_cC, sesDET ? 0 : sesFT), line.style_solid, sesLNW)
            lnSLc := line.new(b.i, b.l, b.i, b.l, xloc.bar_index, extend.none, color.new(_cC, sesDET ? 0 : sesFT), line.style_solid, sesLNW)
           
            if _bg
                linefill.new(lnSHc, lnSLc, color.new(_cC, sesFT))

            if sesNM
                bxSTc := box.new (b.i, b.l, b.i, b.l, text = _cSes, text_size = size.tiny, text_halign = text.align_left, text_valign = text.align_top, 
                               text_color = color.new(_cC, 25), bgcolor = color(na), border_color = color(na))

        if cSES
            lnSHc.set_y1(math.max(b.h, lnSHc.get_y1())), lnSHc.set_y2(math.max(b.h, lnSHc.get_y2())), lnSHc.set_x2(b.i)
            lnSLc.set_y1(math.min(b.l, lnSLc.get_y1())), lnSLc.set_y2(math.min(b.l, lnSLc.get_y2())), lnSLc.set_x2(b.i)

            if sesNM
                bxSTc.set_bottom(math.min(b.l, lnSLc.get_y1())), bxSTc.set_top(math.min(b.l, lnSLc.get_y1()))

        if not cSES and cSES != cSES[1]
            S.lnSHp := line.new(b.i - 1, lnSHc.get_y1(), b.i, lnSHc.get_y2(), xloc.bar_index, extend.none, _mm ? _cC : color(na), line.style_dotted, sesLNW)
            S.lnSMp := line.new(b.i - 1, math.avg(lnSHc.get_y1(), lnSLc.get_y1()), b.i, math.avg(lnSHc.get_y2(), lnSLc.get_y2()), xloc.bar_index, extend.none, _sM ? _cC : color(na), line.style_dotted, sesLNW)
            S.lnSLp := line.new(b.i - 1, lnSLc.get_y1(), b.i, lnSLc.get_y2(), xloc.bar_index, extend.none, _mm ? _cC : color(na), line.style_dotted, sesLNW)

            S.bsB := false, S.bzB := false
            S.ssB := false, S.szB := false

            if _cSes == ldnST and nyamSH
                S.fSHp := lnSHc.get_y1()
                S.fSLp := lnSLc.get_y1()
                llnSHc := line.new(b.i - 1, S.fSHp, b.i, S.fSHp, xloc.bar_index, extend.none, _mm ? _cC : color(na), line.style_dotted, sesLNW)
                llnSMc := line.new(b.i - 1, math.avg(S.fSHp, S.fSLp), b.i, math.avg(S.fSHp, S.fSLp), xloc.bar_index, extend.none, _sM ? _cC : color(na), line.style_dotted, sesLNW)
                llnSLc := line.new(b.i - 1, S.fSLp, b.i, S.fSLp, xloc.bar_index, extend.none, _mm ? _cC : color(na), line.style_dotted, sesLNW)
                S.lbsB := false, S.lbzB := false
                S.lssB := false, S.lszB := false
            else if _cSes == nypmST
                S.fSHp := 10e6
                S.fSLp := 0

        if not cSES
            S.lnSHp.set_x2(b.i - 1)
            S.lnSMp.set_x2(b.i - 1)
            S.lnSLp.set_x2(b.i - 1)

            if _cSes == ldnST and S.fSLp != 0
                llnSHc.set_x2(b.i - 1)
                llnSMc.set_x2(b.i - 1)
                llnSLc.set_x2(b.i - 1)

    if swpBZ
        pSH = S.lnSHp.get_y1()

        if not S.bsB

            if b.h > pSH and b.o < pSH
                alert(syminfo.ticker + ' buyside session level breached, price ' + str.tostring(b.c, format.mintick) + ', timeframe ' + timeframe.period, alert.freq_once_per_bar)
                S.bzBX := box.new (b.i - 1, math.min(pSH + swpBM * swpATR, b.h), b.i + 1, pSH, bgcolor = swpBC, border_color = color(na))

                S.bzB := true
                S.bsB := true

        else if S.bzB

            if b.l > pSH - swpBM * swpATR and b.h < pSH + swpBM * swpATR
                S.bzBX.set_top(math.max(b.h, S.bzBX.get_top()))

                if b.h > pSH
                    S.bzBX.set_right(b.i + 1)
                na
            else
                if b.c > pSH + swpBM * swpATR * 1.5
                    S.bzBX.set_bgcolor(swpHF ? color(na) : swpFC)
                    S.bzBX.set_right(b.i)
                    S.bzB := false
                else if b.i - S.bzBX.get_right() >= swpML
                    if b.h > pSH + swpBM * swpATR
                        S.bzBX.set_bgcolor(swpHF ? color(na) : swpFC)
                        S.bzBX.set_right(b.i + 1)

                    S.bzB := false
                    if not swpDT
                        S.bsB := false

        if _cSes == ldnST and nyamSH
            lpSH = S.fSHp

            if not S.lbsB

                if b.h > lpSH and b.o < lpSH
                    alert(syminfo.ticker + ' buyside session level breached, price ' + str.tostring(b.c, format.mintick) + ', timeframe ' + timeframe.period, alert.freq_once_per_bar)
                    S.lbzBX := box.new (b.i - 1, math.min(lpSH + swpBM * swpATR, b.h), b.i + 1, lpSH, bgcolor = swpBC, border_color = color(na))

                    S.lbzB := true
                    S.lbsB := true

            else if S.lbzB

                if b.l > lpSH - swpBM * swpATR and b.h < lpSH + swpBM * swpATR
                    S.lbzBX.set_top(math.max(b.h, S.lbzBX.get_top()))

                    if b.h > lpSH
                        S.lbzBX.set_right(b.i + 1)
                    na
                else
                    if b.c > lpSH + swpBM * swpATR * 1.5
                        S.lbzBX.set_bgcolor(swpHF ? color(na) : swpFC)
                        S.lbzBX.set_right(b.i)
                        S.lbzB := false
                    else if b.i - S.lbzBX.get_right() >= swpML
                        if b.h > lpSH + swpBM * swpATR
                            S.lbzBX.set_bgcolor(swpHF ? color(na) : swpFC)
                            S.lbzBX.set_right(b.i + 1)

                        S.lbzB := false
                        if not swpDT
                            S.lbsB := false

    if swpSZ
        pSL = S.lnSLp.get_y1()

        if not S.ssB

            if b.l < pSL and b.o > pSL
                alert(syminfo.ticker + ' sellside session level breached, price ' + str.tostring(b.c, format.mintick) + ', timeframe ' + timeframe.period, alert.freq_once_per_bar)
                S.szBX := box.new (b.i - 1, pSL, b.i + 1, math.max(pSL - swpSM * swpATR, b.l), bgcolor = swpSC, border_color = color(na))

                S.szB := true
                S.ssB := true

        else if S.szB

            if b.l > pSL - swpSM * swpATR and b.h < pSL + swpSM * swpATR
                S.szBX.set_bottom(math.min(b.l, S.szBX.get_bottom()))

                if b.l < pSL
                    S.szBX.set_right(b.i + 1)
                na
            else
                if b.c < pSL - swpSM * swpATR * 1.5
                    S.szBX.set_bgcolor(swpHF ? color(na) : swpFC)
                    S.szBX.set_right(b.i + 1)
                    S.szB := false
                else if b.i - S.szBX.get_right() >= swpML
                    if b.l < pSL - swpSM * swpATR
                        S.szBX.set_bgcolor(swpHF ? color(na) : swpFC)
                        S.szBX.set_right(b.i + 1)

                    S.szB := false
                    if not swpDT
                        S.ssB := false

        if _cSes == ldnST and nyamSH
            lpSL = S.fSLp

            if not S.lssB

                if b.l < lpSL and b.o > lpSL
                    alert(syminfo.ticker + ' sellside session level breached, price ' + str.tostring(b.c, format.mintick) + ', timeframe ' + timeframe.period, alert.freq_once_per_bar)
                    S.lszBX := box.new (b.i - 1, lpSL, b.i + 1, math.max(lpSL - swpSM * swpATR, b.l), bgcolor = swpSC, border_color = color(na))

                    S.lszB := true
                    S.lssB := true

            else if S.lszB

                if b.l > lpSL - swpSM * swpATR and b.h < lpSL + swpSM * swpATR
                    S.lszBX.set_bottom(math.min(b.l, S.lszBX.get_bottom()))

                    if b.l < lpSL
                        S.lszBX.set_right(b.i + 1)
                    na
                else
                    if b.c < lpSL - swpSM * swpATR * 1.5
                        S.lszBX.set_bgcolor(swpHF ? color(na) : swpFC)
                        S.lszBX.set_right(b.i)
                        S.lszB := false
                    else if b.i - S.lszBX.get_right() >= swpML
                        if b.l < lpSL - swpSM * swpATR
                            S.lszBX.set_bgcolor(swpHF ? color(na) : swpFC)
                            S.lszBX.set_right(b.i + 1)

                        S.lszB := false
                        if not swpDT
                            S.lssB := false

method clear(FVG _id) =>
    _id.uFVG.pop()

method fvgUpdate(FVG _id, _h, _l, _p) =>
    cUB = _id.uFVG.get(0)
    tUB = cUB.get_top()
    bUB = cUB.get_bottom()

    if _h > bUB and _l < tUB
        if _p
            if _l > bUB
                na
            else
                fvg.clear()

        else
            if _h < tUB
                na
            else
                fvg.clear()

    cUB.set_right(b.i)

//-----------------------------------------------------------------------------}
// Calculations - Sessions Tabular View
//-----------------------------------------------------------------------------{

S.s.set(0, asST)
S.oH.set(S.s.indexof(asST)  , str.tonumber(str.substring(asSRT  , 0, str.pos(asSRT  , ":"))))
S.cH.set(S.s.indexof(asST)  , str.tonumber(str.substring(asEND  , 0, str.pos(asEND  , ":"))))

S.s.set(1, ldnST)
S.oH.set(S.s.indexof(ldnST), str.tonumber(str.substring(ldnSRT , 0, str.pos(ldnSRT , ":"))))
S.cH.set(S.s.indexof(ldnST), str.tonumber(str.substring(ldnEND , 0, str.pos(ldnEND , ":"))))

S.s.set(2, nyamST)
S.oH.set(S.s.indexof(nyamST) , str.tonumber(str.substring(nyamSRT, 0, str.pos(nyamSRT, ":"))))
S.cH.set(S.s.indexof(nyamST) , str.tonumber(str.substring(nyamEND, 0, str.pos(nyamEND, ":"))))

S.s.set(3, nypmST)
S.oH.set(S.s.indexof(nypmST) , str.tonumber(str.substring(nypmSRT, 0, str.pos(nypmSRT, ":"))))
S.cH.set(S.s.indexof(nypmST) , str.tonumber(str.substring(nypmEND, 0, str.pos(nypmEND, ":"))))

forex_n_cdf  = syminfo.type == 'forex' or syminfo.type == 'cfd'

statPosition = switch sesPOS
    'Top Left'      => position.top_left
    'Top Center'    => position.top_center
    'Top Right'     => position.top_right
    'Middle Right'  => position.middle_right
    'Bottom Left'   => position.bottom_left
    'Bottom Center' => position.bottom_center

hide = hIfN ? forex_n_cdf ? true : false : true

if barstate.islast and sesTSH and hide
    var table clock = table.new(statPosition, 3, 4, border_width = 3)

    ses = f_sesDet(asST, false)
    sesC = str.contains(ses, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 0, "â–ˆ", text_size = sesTS, text_color = asC)
    table.cell(clock, 1, 0, asST , text_color = asC, bgcolor = color.new(asC, 75), text_halign = text.align_left, text_size = sesTS)
    table.cell(clock, 2, 0, ses, text_color = sesC, bgcolor = color.new(sesC, 75), text_halign = text.align_left, text_size = sesTS)

    ses := f_sesDet(ldnST, ldnDST)
    sesC := str.contains(ses, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 1, "â–ˆ", text_size = sesTS, text_color = ldnC)
    table.cell(clock, 1, 1, ldnST , text_color = ldnC, bgcolor = color.new(ldnC, 75), text_halign = text.align_left, text_size = sesTS)
    table.cell(clock, 2, 1, ses, text_color = sesC, bgcolor = color.new(sesC, 75), text_halign = text.align_left, text_size = sesTS)

    ses := f_sesDet(nyamST, nyDST)
    sesC := str.contains(ses, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 2, "â–ˆ", text_size = sesTS, text_color = nyamC)
    table.cell(clock, 1, 2, nyamST , text_color = nyamC, bgcolor = color.new(nyamC, 75), text_halign = text.align_left, text_size = sesTS)
    table.cell(clock, 2, 2, ses, text_color = sesC , bgcolor = color.new(sesC, 75), text_halign = text.align_left, text_size = sesTS)

    ses := f_sesDet(nypmST, nyDST)
    sesC := str.contains(ses, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 3, "â–ˆ", text_size = sesTS, text_color = nypmC)
    table.cell(clock, 1, 3, nypmST, text_color = nypmC, bgcolor = color.new(nypmC, 75), text_halign = text.align_left, text_size = sesTS)
    table.cell(clock, 2, 3, ses, text_color = sesC , bgcolor = color.new(sesC, 75), text_halign = text.align_left, text_size = sesTS)

//-----------------------------------------------------------------------------}
// Calculations - Sessions
//-----------------------------------------------------------------------------{

if timeframe.isintraday and tfM <= 5
    f_pSWP(asSH  , asST  , ldnSH  ? ldnST  : nyamSH ? nyamST : nypmSH ? nypmST : asST  , false , asC  , asMMP  , asBG  , asSM  )
    f_pSWP(ldnSH , ldnST , nypmSH ? nypmST : asSH   ? asST   : ldnST , ldnDST, ldnC , ldnMMP , ldnBG , ldnSM )
    f_pSWP(nyamSH, nyamST, nypmSH ? nypmST : asSH   ? asST   : ldnSH  ? ldnST  : nyamST, nyDST , nyamC, nyamMMP, nyamBG, nyamSM)
    f_pSWP(nypmSH, nypmST, asSH   ? asST   : ldnSH  ? ldnST  : nyamSH ? nyamST : nypmST, nyDST , nypmC, nypmMMP, nypmBG, nypmSM) 
else
    var table note = table.new(position.bottom_right, 1, 1)
    if barstate.islast
        table.cell(note, 0, 0, 'Session Sweeps are supported on:       \n 1 min, 3 mins and 5 mins charts\n\n', text_size=size.small, text_color=chart.fg_color)

//-----------------------------------------------------------------------------}
// Calculations - Market Structure Shifts
//-----------------------------------------------------------------------------{

pp_h = ta.pivothigh(mssLN, mssLN)
pp_l = ta.pivotlow (mssLN, mssLN)

if not na(pp_h)
    pp.h  := pp_h
    pp.hx := false
    pp.ht := b.i - mssLN

if not na(pp_l)
    pp.l  := pp_l
    pp.lx := false
    pp.lt := b.i - mssLN

if mssSH
    if b.c > pp.h and not pp.hx
        pp.hx := true

        if shift == -1
            line.new(pp.ht, pp.h, b.i, pp.h, color = ppLCB)
            box.new (pp.ht, pp.h, b.i, pp.h, text = 'CHoCH', text_size = size.tiny, text_halign = text.align_left, text_valign = text.align_bottom, 
                      text_color = ppLCB, bgcolor = color(na), border_color = color(na))
        shift := 1

    if b.c < pp.l and not pp.lx
        pp.lx := true

        if shift == 1
            line.new(pp.lt, pp.l, b.i, pp.l, color = ppLCS)
            box.new (pp.lt, pp.l, b.i, pp.l, text = 'CHoCH', text_size = size.tiny, text_halign = text.align_left, text_valign = text.align_top, 
                      text_color = ppLCS, bgcolor = color(na), border_color = color(na))
        shift := -1

//-----------------------------------------------------------------------------}
// Calculations - Fair Value Gaps
//-----------------------------------------------------------------------------{

if fvgSH
    bullG = b.l > b.h[1]
    bearG = b.h < b.l[1]

    bull  = (b.l - b.h[2]) > fvgATR and b.l > b.h[2] and b.c[1] > b.h[2] and not (bullG or bullG[1])

    if bull 
        if fvg.uFVG.size() > 0
            fvg.clear()

        fvg.uFVG.push(box.new (b.i - 1, b.l, b.i, b.h[2], na, bgcolor = fvgBC))

        last := true

    bear  = (b.l[2] - b.h) > fvgATR and b.h < b.l[2] and b.c[1] < b.l[2] and not (bearG or bearG[1])

    if bear 
        if fvg.uFVG.size() > 0
            fvg.clear()

        fvg.uFVG.push(box.new (b.i - 1, b.l[2], b.i, b.h, na, bgcolor = fvgSC))

        last := false

    if bullG or bearG
        if fvg.uFVG.size() > 0
            fvg.clear()

    if fvg.uFVG.size() > 0
        fvg.fvgUpdate(b.h, b.l, last)

//-----------------------------------------------------------------------------}
